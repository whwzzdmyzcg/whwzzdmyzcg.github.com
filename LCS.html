<!DOCTYPE html>
<html>
	<head>
		<meta charset='utf-8'>
		<meta http-equiv="X-UA-Compatible" content="chrome=1">
		<link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
		<link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
		<link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<title>LCS</title>
	</head>
<body>
	<div id="container">
		<div class="inner">

			<header>
				<h1>Rachel's Wiki World</h1>
				<!--<h2>Rachel's Wiki World</h2>-->
			</header>

			<section id="downloads" class="clearfix">
				<a href="https://github.com/whwzzdmyzcg" id="view-on-github" class="button"><span>View on GitHub</span></a>
			</section>

			<hr>

		<section id="main_content">
		
<h2 id="toc_0.1">LCS</h2>
<h3 id="toc_0.1.1">题目</h3>
<p>
长度分别为m和n的字符串A和B，确定二者的最长公共子序列(LCS, Longest Common Subsequence)的长度。
串和序列的区别：
串是字符构成的连续的有先后顺序的队列。
序列是可能不连续的有先后顺序的字符串。
</p>
<h3 id="toc_0.1.2">分析</h3>
<p>
最笨的方法是蛮力搜索。
用动态规划方法。
动态规划步骤：
</p>
<ol>
<li>
分析抽象，得出递归式。

<li>
分析子问题个数：多项式级，可以用动态规划来解；指数级，不能用动态规划来解。

<li>
采用自底向上的分析求子问题的最优解。

</ol>
<p>
A和B的LCS长度的递推式：
</p>
<ul>
<li>
L[i][j] = 0, if i=0 or j=0(此时A和/或B为空串)

<li>
L[i][j] = L[i-1][j-1]+1, if i&gt;0 and j&gt;0 and A[i]=B[j]

<li>
L[i][j] = max(L[i][j-1], L[i-1][j]), if i&gt;0 and j&gt;0 and A[i]!=B[j]

</ul>
<p>
PS:LCS可能不唯一。
</p>
<h3 id="toc_0.1.3">LCS</h3>
<p>
Input:字符串A和B，长度分别为m和n。
Output:A和B的LCS的长度
</p>
<pre>
for (i = 0; i &lt;= m; i++) // 置第0行为0
	L[i][0] = 0;
for (j = 0; j &lt;= n; j++) // 置第0列为0
	L[0][j] = 0;
for (i = 1; i &lt;= m; i++)
	for (j = 1; j &lt;= n; j++)
	{
		if (A[i-1] == B[j-1])
			L[i][j] = L[i-1][j-1] + 1;
		else
			L[i][j] = L[i][j-1] &gt; L[i-1][j] ? L[i][j-1] : L[i-1][j];
	}
return L[m][n];
</pre>
<p>
时间复杂度O(m*n)，空间复杂度O(m*n)。
</p>
<h3 id="toc_0.1.4">LCS-1</h3>
<p>
把空间复杂度降为O(min(m,n))。
<img src="images/LCS.png" />
</p>
<pre>
m = A.length();
n = B.length();
len = m&lt;n ? m+1 : n+1;
int L[len];
for (i = 0; i &lt; m; i++)
{
	k = 1;
	// 每次外层循环之前，置tmp0为数组L首元素的值
	tmp0 = L[0];
	for (j = 0; j &lt; n; j++)
	{
		tmp1 = L[k]; // 保存即将被改变的L[k]
		if (A[i] == B[j])
		{
			L[k] = tmp0 + 1;
		}
		else 
		{
			L[k] = L[k-1] &gt; L[k] ? L[k-1] : L[k];
		}
		tmp0 =tmp1; // 保存原L[k]供L[k+1]使用
		k++;
	}
}
</pre>
<h3 id="toc_0.1.5">LCS-2</h3>
<ul>
<li>
输出LCS。

</ul>

		</section>

		<footer>
		This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="http://twitter.com/jasonlong">Jason Long</a>.
		</footer>


		</div>
	</div>
</body>
</html>
